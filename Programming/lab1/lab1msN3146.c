// Суханкулиев Мухаммет N3146, 341992, ПРОГР-1.2; Вариант 1-11
// Тип числа - unsigned short
/* Задание
Назовем характеристикой байта количество единичных битов.
Инвертировать в байтах с самой маленькой характеристикой старшую тетраду,
а в байтах с самой большой характеристикой — младшую тетраду. */

// Рекомендую включить отладочный вывод, я долго работал над этим =)

#include <stdlib.h>
#include <stdio.h>
#include <time.h> // Для srand()
#include <ctype.h> // Для isdigit()

#include "functions.h" // 2 свои функции is_hex(), hex_to_dec()

int main(int argc, char *argv[]) {
    // Проверка запуска с переменной среды, включающей отладочный вывод.
    // Пример запуска с установкой переменной LAB1DEBUG в 1:
    // $ LAB1DEBUG=1 ./lab1msN3146 123
    char *DEBUG = getenv("LAB1DEBUG");
    if (DEBUG) {
        fprintf(stderr, "Включен вывод отладочных сообщений\n");
    }
    
    if (argc > 2) { // Изменил знак != на >, а то если введено 1 значение, не генерируется случайное число
        fprintf(stderr, "Usage: %s [число]\n", argv[0]);
        return EXIT_FAILURE; 
    }
    
    //
    // Тут может быть ваш код. В этом файле Вы можете поменять все, что угодно.
    // Главное - чтобы потом все правильно работало ;-)

    int n, i; // Если использовать unsigned short - не выполняется строка 73
    unsigned char byte1, byte2;

    // Проверяем входное значение в командной строке
    if (argc == 2) {
        // Если вводится 0х - то шестнадцатеричное число
        if (argc == 2 && argv[1][0] == '0' && (argv[1][1] == 'x' || argv[1][1] == 'X')) {
            if (!is_hex(argv[1] + 2)) {
                fprintf(stderr, "После '0x' вводится шестнадцатеричное число\n");
                return EXIT_FAILURE;
            }
        n = hex_to_dec(argv[1]);
        } else {
            if (argv[1][0] == '-') {
                fprintf(stderr, "Unsigned short - положительное число...\n");
                return EXIT_FAILURE;
            // Если же не вводится 0х - то десятичное
            } else {
                n = (int)atoi(argv[1]);
            }
        }
        // Проверка на корректность значения
        for (int i = 0; argv[1][i] != '\0'; i++) {
            if (!isdigit(argv[1][i]) && argv[1][0] != '0' && argv[1][1] != 'x') {
                fprintf(stderr, "'%s' не число, ало\n", argv[1]);
                return EXIT_FAILURE;
            }            
        }
    // Если число не указано, генерируем случайное
    }
    if (argc == 1) {
        if (DEBUG) {
            printf("Генерация случайного числа...\n");
        }
        srand(time(NULL));
        n = rand() % 65536;
    } 
    // Проверка диапазона Unsigned short
    if (n < 0 || n > 65535) {
        fprintf(stderr, "Unsigned short - это когда больше 0 и меньше 65535, чел...\n");
        return EXIT_FAILURE;
    }

    if (DEBUG) {
        printf("Введенное число в десятичной СС:              n = %d\n", n);
        
        // Вывод двоичного представления числа до преобразования
        printf("Двоичное представление числа:                 ");
    }

    for (i = 15; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
        if (i % 8 == 0) {
            printf(" ");
        }
    }
    printf("\n");

    // Разделение числа n на два байта
    byte1 = (n >> 8) & 0xFF;
    byte2 = n & 0xFF;
    // Сравнение байтов по характеристикам (по количесву единиц)
    int charact1 = __builtin_popcount(byte1);
    int charact2 = __builtin_popcount(byte2);

    // Преобразование
    if (charact1 >= charact2) { // Если характеристики равны, бОльшим считается первый байт
        // Инвертирование младшей тетрады в первом байте и старшей тетрады во втором байте
        byte2 ^= 0xF0;
        byte1 ^= 0x0F;
    } else {
        // Инвертирование младшей тетрады во втором байте и старшей тетрады в первом байте
        byte1 ^= 0xF0;
        byte2 ^= 0x0F;
    }

    // Вывод двоичного представления числа после преобразования
    if (DEBUG) {
        printf("Двоичное представление после преобразования:  ");
    }
    for (i = 15; i >= 0; i--) {
        printf("%d", (byte1 << 8 | byte2) >> i & 1);
        if (i % 8 == 0) {
            printf(" ");
        }
    }
    printf("\n");

    n = (byte1 << 8 | byte2);
    // Вывод преобразованного числа в десятичном и в шестнадцатеричном виде
    if (DEBUG) {
        printf("Преобразованное число: Десятичный вид:        ");
        printf("%d\n                       Шестнадцатеричный вид: 0x%X\n", n, n);
    }

    //
    
    return EXIT_SUCCESS;
}

// PS Вроде все замечания учел, но не использовал sscanf(), т.к. atoi() лучше =)
